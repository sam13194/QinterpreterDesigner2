"""PyQuil quantum circuit translator."""

from pyquil import Program
from pyquil.gates import CCNOT, CNOT, CPHASE, MEASURE, RX, RY, RZ, SWAP, H, X, Y, Z

from quantumgateway.quantum_translator.quantum_translator import QuantumTranslator


class PyQuilCircuit:
    """Wrapper class for PyQuil programs with simulation capabilities."""

    def __init__(self, program):
        """Initialize the PyQuil circuit wrapper.

        Args:
            program: The PyQuil program object.
        """
        self.program = program

    def print_circuit(self):
        """Print the circuit representation."""
        print(self.program)

    def simulate(self, shots=100):
        """Simulate the circuit using PyQuil's QVM.

        Args:
            shots (int, optional): Number of measurement shots. Defaults to 100.

        Returns:
            dict: Measurement counts with bit ordering matching other frameworks.
        """
        from collections import Counter

        from pyquil.api import get_qc
        from pyquil.quil import address_qubits
        from pyquil.quilbase import Declare, Gate

        # Connect to the Quantum Virtual Machine (QVM)
        qc = get_qc("9q-square-qvm")  # Or another QVM type as needed

        # Declare classical register only if not already declared
        ro_exists = any(
            [
                isinstance(instr, Declare) and instr.name == "ro"
                for instr in self.program.instructions
            ]
        )
        if not ro_exists:
            num_qubits = (
                max(
                    [
                        gate.qubits[-1].index
                        for gate in self.program.instructions
                        if isinstance(gate, Gate)
                    ]
                )
                + 1
            )
            self.program.declare("ro", "BIT", num_qubits)

        # Compile the program
        compiled_program = qc.compile(address_qubits(self.program))

        # Initialize results
        results = []

        # Execute the program on the QVM for the specified number of shots
        for _ in range(shots):
            result = qc.run(compiled_program)
            results.append("".join(map(str, result.readout_data["ro"][0]))[::-1])

        # Convert the results to a frequency distribution
        counts = Counter(results)

        return counts


class PyQuilTranslator(QuantumTranslator):
    """Translator for converting circuits to PyQuil format.

    This class handles the translation of high-level quantum circuits
    to PyQuil's program representation.
    """

    def translate(self, hl_circuit):
        """Translate high-level circuit to PyQuil format.

        Args:
            hl_circuit: The high-level quantum circuit to translate.

        Returns:
            PyQuilCircuit: Wrapped PyQuil program with simulation capabilities.
        """
        program = Program()
        qubits = list(range(hl_circuit.num_qubits))
        ro = program.declare("ro", "BIT", hl_circuit.num_qubits)
        for gate in hl_circuit.gates:
            if gate.name.lower() == "h":
                program += H(qubits[gate.qubits[0]])
            elif gate.name.lower() == "x":
                program += X(qubits[gate.qubits[0]])
            elif gate.name.lower() == "y":
                program += Y(qubits[gate.qubits[0]])
            elif gate.name.lower() == "z":
                program += Z(qubits[gate.qubits[0]])
            elif gate.name.lower() == "cnot":
                program += CNOT(qubits[gate.qubits[0]], qubits[gate.qubits[1]])
            elif gate.name.lower() == "rx":
                program += RX(gate.params[0], qubits[gate.qubits[0]])
            elif gate.name.lower() == "ry":
                program += RY(gate.params[0], qubits[gate.qubits[0]])
            elif gate.name.lower() == "rz":
                program += RZ(gate.params[0], qubits[gate.qubits[0]])
            elif gate.name.lower() == "toffoli":
                program += CCNOT(
                    qubits[gate.qubits[0]],
                    qubits[gate.qubits[1]],
                    qubits[gate.qubits[2]],
                )
            elif gate.name.lower() == "swap":
                program += SWAP(qubits[gate.qubits[0]], qubits[gate.qubits[1]])
            elif gate.name.lower() == "cphase":
                program += CPHASE(gate.params[0], qubits[gate.qubits[0]], qubits[gate.qubits[1]])
            elif gate.name.lower() == "cz":
                program += Z(qubits[gate.qubits[1]]).controlled(qubits[gate.qubits[0]])
            elif gate.name.lower() == "cy":
                cy_gate = Y(qubits[gate.qubits[1]]).controlled()
                program += cy_gate(qubits[gate.qubits[0]], qubits[gate.qubits[1]])
            elif gate.name.lower() == "measure":
                program += MEASURE(qubits[gate.qubits[0]], ro[gate.qubits[0]])
        return PyQuilCircuit(program)
